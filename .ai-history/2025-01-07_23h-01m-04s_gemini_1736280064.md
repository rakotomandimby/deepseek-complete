# Error executing vim.schedule lua callback : rktmb-deepseek-complete.lua:46: Invalid `col` : out of range

When `M.set_suggestion_extmark()` is called with the suggestion returned by the DeepSeek API, I get the following error:

```
Error executing vim.schedule lua callback : rktmb-deepseek-complete.lua:46: Invalid `col` : out of range
```

I have no data sample to reproduce this error, may be you can find it out.
Analyze the code and tell me what actions should be made.



# This is gemini-exp-1206 answer (3k in, 1k out)

The error `rktmb-deepseek-complete.lua:46: Invalid 'col' : out of range` arises because the column (`col`) where the virtual text (suggestion) is being placed goes beyond the current line's length. This happens when the suggestion is multi-lined, and subsequent lines of the suggestion are attempted to be placed at the same `col` as the first line, which might be beyond the end of those lines.

Here's the corrected `lua/rktmb-deepseek-complete.lua` and an explanation of the changes:

```lua
-- lua/rktmb-deepseek-complete.lua
local M = {}

-- ... (other functions remain unchanged)

function M.set_suggestion_extmark(suggestion)
  local current_buf = vim.api.nvim_get_current_buf()
  local position = vim.api.nvim_win_get_cursor(0)
  local row = position[1] - 1 -- Adjust to 0-based indexing
  local initial_col = position[2]  -- Store the initial column

  -- Split the suggestion into lines
  local lines = vim.split(suggestion, '\n', true)

  -- Create virtual text segments for each line
  local virt_text_lines = {}
  for _, line in ipairs(lines) do
    table.insert(virt_text_lines, {line, "Comment"})
  end

  -- Insert each line as a separate extmark, adjusting the column
  for i, line in ipairs(lines) do
    local extmark_row = row + i - 1 -- Increment the row for each line
    local col = 0  -- Reset col to 0 for subsequent lines, or use initial_col for the first line

    if i == 1 then
      col = initial_col
    end


    local opts = {
      virt_text = {{line, "Comment"}},
      virt_text_pos = 'overlay' -- Place the virtual text above the real text.
    }

    if _G.current_extmark_id then
      -- Update existing extmark.  Clear previous multi-line extmarks first.
      vim.api.nvim_buf_del_extmark(current_buf, _G.ns_id, _G.current_extmark_id)
      _G.current_extmark_id = vim.api.nvim_buf_set_extmark(current_buf, _G.ns_id, extmark_row, col, opts)
    else
      -- Create new extmark
      _G.current_extmark_id = vim.api.nvim_buf_set_extmark(current_buf, _G.ns_id, extmark_row, col, opts)
    end
  end
end

-- ... (rest of the module)

return M
```


Key Changes and Explanation:

1. **Column Reset:** The `col` is reset to `0` for each subsequent line of the suggestion within the loop.  This ensures that the virtual text for these lines starts at the beginning of the line, preventing the "out of range" error.  The `initial_col` is used only for the first line of the suggestion.

2. **`virt_text_pos = 'overlay'`:** This option is added to the `opts` table. It ensures that the virtual text is displayed *above* the actual text, preventing it from interfering with the cursor position and potentially causing further issues.  This is important for multi-line suggestions.

3. **Clearing Previous Extmarks:** Before setting a new multi-line extmark, the previous one is deleted using `vim.api.nvim_buf_del_extmark`. This prevents the accumulation of extmarks and potential conflicts.  This is especially important when dealing with multi-line suggestions that might change with each API call.


With these changes, the multi-line suggestions should be displayed correctly without causing the `col` out of range error.  The `virt_text_pos` option further improves the user experience by preventing the virtual text from interfering with the cursor and text input.  The clearing of previous extmarks ensures a clean slate for each new suggestion.



No changes are needed in `plugin/init.lua`.  The issue was isolated to the `set_suggestion_extmark` function.  Make sure to reload your Neovim configuration after making these changes.  If the error persists, provide a minimal reproducible example (including the buffer content and cursor position) so I can further assist you.

