# E5560: Vimscript function must not be called in a Lua callback

In `./plugin/init.lua` I have a function `process_deepseek_response()` that is called in the callback of the curl request.
The problem is that the function `process_deepseek_response()` must decode a json string, but it is a vimscript function.

Propose me the changes needed to make to able to decode the json in the response.
I think about using something linke `vim.schedule`, `vim.schedule_wrap`, or any `vim.*` function that could help me.





# This is gemini-exp-1206 answer (2k in, 1k out)

The issue is that you're trying to use `vim.fn.json_decode` (which calls a Vimscript function under the hood) within a Lua callback.  Lua callbacks are executed asynchronously, and you can't directly call Vimscript functions from them.  You need to schedule the Vimscript execution using `vim.schedule`.

Here's the corrected `plugin/init.lua`:

```lua
local rktmb_deepseek_complete = require("rktmb-deepseek-complete")
local curl = require('plenary.curl')

_G.ns_id = vim.api.nvim_create_namespace('rktmb-deepseek-complete')

_G.current_extmark_id = nil
_G.current_suggestion = nil

-- Default keymappings
local default_opts = {
  deepseek_api_key = os.getenv("DEEPSEEK_API_KEY"),
  suggest_lines_keymap = "<M-ESC>",
  accept_all_keymap = "<M-PageDown>",
  accept_line_keymap = "<M-Down>",
}

-- Read user configuration
local user_opts = vim.tbl_deep_extend("force", default_opts, vim.g.rktmb_deepseek_complete_opts or {})


local function process_deepseek_response(response)
  vim.schedule(function()  -- Schedule the json_decode call
    local response_body = vim.fn.json_decode(response.body)
    if response_body.choices and #response_body.choices > 0 then
      local choice = response_body.choices[1]
      local suggestion = choice.message.content
      rktmb_deepseek_complete.log("\n\nSuggestion from DeepSeek API:")
      rktmb_deepseek_complete.log(suggestion)

      -- Now that you have the suggestion, you can do something with it,
      -- like setting _G.current_suggestion.  Make sure this part is also
      -- inside the vim.schedule call.
      _G.current_suggestion = suggestion

    end
  end)
end


_G.suggest = function()

  local deepseek_request_body = {
    model = "deepseek-chat",
    echo = false,
    frequency_penalty = 0,
    max_tokens = 4096,
    presence_penalty = 0,
    stop = nil,
    stream = false,
    stream_options = nil,
    temperature = 1,
    top_p = 1,
    messages = rktmb_deepseek_complete.build_messages_table(
      rktmb_deepseek_complete.get_text_before_cursor(),
      rktmb_deepseek_complete.get_text_after_cursor()
    )
  }

  -- Asynchronously make the POST request
  curl.post('https://api.deepseek.com/chat/completions', {
    body = vim.fn.json_encode(deepseek_request_body),
    headers = {
      ["Content-Type"] = "application/json",
      ["Accept"] = "application/json",
      ["Authorization"] = "Bearer " .. user_opts.deepseek_api_key
    },
    callback = function(response)
      rktmb_deepseek_complete.log("Response from DeepSeek API:")
      rktmb_deepseek_complete.log(response.body)
      process_deepseek_response(response) -- Call the function that now uses vim.schedule
    end
  })
end


vim.api.nvim_create_autocmd("InsertLeave", {
  pattern = "*",
  callback = function()
    vim.api.nvim_buf_clear_namespace(0, ns_id, 0, -1)
  end
})


vim.api.nvim_set_keymap("i", user_opts.suggest_lines_keymap, "<Cmd>lua suggest()<CR>",                     { noremap = true, silent = true })


```

Key changes:

* **`vim.schedule` wrapper:** The entire body of `process_deepseek_response` is now wrapped in `vim.schedule(function() ... end)`. This ensures that the code inside, including `vim.fn.json_decode`, runs in the main Neovim event loop, not in the asynchronous callback.
* **Handling the suggestion:** I've added a placeholder comment where you should handle the `suggestion` after it's decoded.  This might involve updating the buffer, displaying the suggestion to the user, etc.  Crucially, this handling *must* also be inside the `vim.schedule` block.


With this change, the `json_decode` call and any subsequent operations on the decoded data will happen safely within the main Neovim thread, avoiding the E5560 error.  Remember to replace the placeholder comment with your actual logic for using the `suggestion`.
