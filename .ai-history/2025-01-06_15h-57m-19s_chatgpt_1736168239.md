# Propose inline suggestions from the random sentence generator

The final goal of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest.
But we are not going to implement all in one go, we are to make it step by step.

- Generate random sentences
- Make an inline suggestion from a random sentence when triggered.
- Have the possibility transform the inline suggestion into regular text (accepting the suggestion).
- Query the DeepSeek API to get suggestions from the content of the buffer.
- Use the DeepSeek API response to suggest completions (dont use the random sentences anymore)

## Step 1: Generate a random sentence

in `./lua/rktmb-deepseek-complete.lua`, there is a function called `generate_sentence()`.
That function generates a multiline random sentence.
This is done.

## Step 2: Make an inline  suggestion from a random sentence when triggered.

When I am in a buffer and in INSERT mode and issue the key sequence `<M-PageDown>`,
The plugin to place de cursor at the end of the line and then insert an inline suggestion 
taken from a random sentence (which is multi line) picked from the list of sentences.
The suggestion appears in grey (#808080).
The suggestion pushes down the lines below it and does not overlap with the text below.
If I continue to type after the suggestion is displayed, the suggestion disappears.
As far as I type, I can trigger the suggestion again and if I continue to type, the suggestion disappears, again and again.

That is the desired behavior.

## Step 3: Have the possibility transform the inline suggestion into regular text (accepting the suggestion).

I want to transform the inline suggestion into regular text because I like that suggested sentence.

With the current `./plugin/init.lua` file,
I issue the `<M-PageUp>` key sequence, the suggestion is transformed into regular text.

But before the suggestion is transformed into regular text, I get the following error:

```
E5108: Error executing lua ....local/share/nvim/lazy/deepseek-complete/plugin/init.lua:74: attempt to get length of field 'current_suggestion' (a nil value)
stack traceback:
....local/share/nvim/lazy/deepseek-complete/plugin/init.lua:74: in function 'accept_suggestion'
[string ":lua"]:1: in main chunk
```


Analyze the code and tell me what makes the error appear but the suggestion is transformed into regular text anyway.




# This is gpt-4o-mini answer (1k in, 1k out)

The error you are encountering is due to the fact that the `current_suggestion` variable is `nil` when you attempt to access its length in the `accept_suggestion` function. Let's analyze the relevant part of the code to understand why this happens.

### Code Analysis

In your `plugin/init.lua`, the `accept_suggestion` function is defined as follows:

```lua
_G.accept_suggestion = function()
  if not _G.current_extmark_id or not _G.current_suggestion then
    -- No active suggestion to accept
    return
  end

  local bufnr = 0
  local cursor_pos = vim.api.nvim_win_get_cursor(0)
  local current_line = cursor_pos[1]

  -- Insert the suggestion lines into the buffer
  -- Lines are inserted below the current line
  vim.api.nvim_buf_set_lines(bufnr, current_line, current_line, false, _G.current_suggestion)

  -- Remove the extmark (inline suggestion)
  vim.api.nvim_buf_del_extmark(bufnr, ns_id, _G.current_extmark_id)

  -- Clear the stored extmark ID and suggestion
  _G.current_extmark_id = nil
  _G.current_suggestion = nil

  -- Optional: Move the cursor to the end of the inserted text
  vim.api.nvim_win_set_cursor(0, { current_line + #_G.current_suggestion, 0 })
end
```

### Error Explanation

1. **Nil Check**: The function starts with a check to see if either `_G.current_extmark_id` or `_G.current_suggestion` is `nil`. If either is `nil`, the function returns early, which is the intended behavior to prevent further execution.

2. **Inserting Lines**: The line that causes the error is:
   ```lua
   vim.api.nvim_buf_set_lines(bufnr, current_line, current_line, false, _G.current_suggestion)
   ```
   If `_G.current_suggestion` is `nil`, this line will throw an error because you cannot get the length of `nil`.

3. **Why the Suggestion is Accepted**: The reason you still see the suggestion being transformed into regular text is that the error occurs after the check for `current_extmark_id`. If the suggestion is still valid (i.e., you haven't typed anything after it), the function will execute the insertion of the suggestion lines. However, if you type after the suggestion, the `current_suggestion` is cleared, leading to the error when you try to accept it again.

### Solution

To fix this issue, you need to ensure that `current_suggestion` is always set correctly before you attempt to access it. Here’s how you can modify the `suggest_random_sentence` function to ensure that it sets `current_suggestion` properly:

1. **Check for Existing Suggestions**: Before generating a new suggestion, check if there is already an active suggestion. If there is, you can either clear it or update it.

2. **Modify the `suggest_random_sentence` Function**: Here’s an updated version of the function:

```lua
_G.suggest_random_sentence = function()
  local current_row = vim.api.nvim_win_get_cursor(0)[1]

  -- Ensure the cursor is at the end of the current line
  local current_line = vim.api.nvim_get_current_line()
  vim.api.nvim_win_set_cursor(0, {current_row, #current_line})

  -- Generate the random sentence
  local sentence = rktmb_deepseek_complete.generate_sentence()
  local lines = vim.split(sentence, "\n", true)

  -- Store the suggestion globally
  _G.current_suggestion = lines

  -- Construct virt_lines with proper formatting
  local virt_lines = {}
  for _, line in ipairs(lines) do
    table.insert(virt_lines, { { line, "Comment" } }) -- Use "Comment" highlight group for grey text
  end

  -- Set the extmark with virt_lines
  local extmark_id = vim.api.nvim_buf_set_extmark(0, ns_id, current_row - 1, 0, {
    virt_lines = virt_lines,
    virt_lines_above = false, -- Place the virtual lines below the current line
    hl_mode = 'combine' -- Combine with existing text highlighting
  })

  -- Store the extmark ID globally
  _G.current_extmark_id = extmark_id

  -- Clear the suggestion on text change or insert leave
  local augroup_id = vim.api.nvim_create_augroup("RktmbDeepseekCompleteSuggestions", { clear = true })
  vim.api.nvim_create_autocmd({ "TextChangedI", "InsertLeave" }, {
    group = augroup_id,
    buffer = 0,
    callback = function()
      vim.api.nvim_buf_del_extmark(0, ns_id, extmark_id)
      _G.current_extmark_id = nil
      _G.current_suggestion = nil
      vim.api.nvim_del_augroup_by_id(augroup_id)
    end
  })
end
```

### Conclusion

By ensuring that `current_suggestion` is properly set and managed, you can avoid the error when trying to accept a suggestion. This will allow you to transform the inline suggestion into regular text without encountering the nil value error.

