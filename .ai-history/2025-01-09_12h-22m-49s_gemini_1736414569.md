# Propose inline suggestions from DeepSeek API

The final purpose of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest completions.

I already have some pieces of code.
I need you to generate the missing parts.

## Step 1: Get the text from the beginning of the current buffer to the cursor

The cursor position is a tuple of (row, column), where row is the line number and column is the character position within the line.
The code to get the text from the beginning of the current buffer to the cursor is `./lua/rktmb-deepseek-complete.lua` function `M.get_text_before_cursor()`.

## Step 2: Get the text from the cursor to the end of the current buffer

In `./lua/rktmb-deepseek-complete.lua` I created the function `M.get_text_after_cursor()` 
that returns the text from the cursor to the end of the current buffer.

## Step 3: Query the DeepSeek API

When the user presses `<M-ESC>`, the function `suggest()` is called. That is the behavior I want.
Also, now, if in INSERT mode and the user presses the space key, `suggest()` is called.

That is the behavior I want.

## Step 4: Insert the suggestion as extmark

Now the suggestion returned by the DeepSeek API is inserted as an extmark.
The extmark starts after the cursor position, NOT at the end of the line.
The suggestion first line is displayed on the same line as the cursor and the remaining lines are displayed below the cursor, 
pushing down the text below the cursor.

That is the expected behavior.

## Step 5: Avoid trigerring the suggestion too often

When the user types fast, the suggestion may only be triggered if the last HTTP response has been received for more than 1 second.
That is the behavior I want.

## Step 6: Clear the suggestion when the user types.

As the user types `<M-ESC>` key, a suggestion is triggered and the suggestion is displayed as an extmark.
If the user continues typing, the suggestion is cleared.
If the types `<M-ESC>` key again, the suggestion is triggered and the new suggestion is displayed when it arrives.
This is repeatable any number of times.

This is the behavior I want.

## Step 7: accept the suggestion word by word

When a suggestion is displayed, I want the user to be able to accept it word by word with the `<M-Right>` key.
So, as far as there is a suggestion, if the user presses `<M-Right>`, 
the first word of the suggestion is accepted and transformed into text at the same position.

Note: Gihub Copilot and Supermaven Neovim plugins do that.

The suggestion might be on the same line as the cursor or on a different line: we have to handle that case.

Tell me the modifications I need to make in order to achieve accepting words of a suggestion and continue to the next line if the suggestion is multiline.



# This is gemini-1.5-pro-latest answer (4k in, 1k out)

The primary change needed is to implement the word-by-word acceptance logic within `M.accept_suggestion_word()`.  Here's the modified `lua/rktmb-deepseek-complete.lua` and how it addresses the multi-line suggestion challenge:

```lua
-- lua/rktmb-deepseek-complete.lua
local M = {}

_G.num_lines_inserted = 0

function M.log(message)
  local log_file = io.open("/tmp/rktmb-deepseek-complete.log", "a")
  if log_file == nil then
    print("Error opening log file")
    return
  end
  log_file:write(message .. "\n")
  log_file:close()
end

function M.remove_markdown_delimiters(text)
  local lines = vim.split(text, "\n", true)
  local new_lines = {}

  for _, line in ipairs(lines) do
    if line:sub(1, 3) == "```" then
      table.insert(new_lines, "\n")
    else
      table.insert(new_lines, line)
    end
  end

  return table.concat(new_lines, "\n")
end

function M.clear_suggestion()
  local current_buf = vim.api.nvim_get_current_buf()
  vim.api.nvim_buf_clear_namespace(current_buf, _G.ns_id, 0, -1)

  if _G.num_lines_inserted and _G.num_lines_inserted > 0 then
    local position = vim.api.nvim_win_get_cursor(0)
    local row = position[1] - 1
    vim.api.nvim_buf_set_lines(current_buf, row + 1, row + 1 + _G.num_lines_inserted, false, {})
    _G.num_lines_inserted = 0
  end
end

local function split_into_words(text)
  return vim.split(text, "%%%%s+", { plain = true })
end

function M.accept_suggestion_word()
  if _G.current_suggestion then
    local words = split_into_words(_G.current_suggestion)
    if #words > 0 then
      local word = words[1]
      local current_buf = vim.api.nvim_get_current_buf()
      local position = vim.api.nvim_win_get_cursor(0)
      local row = position[1] - 1
      local col = position[2]

      vim.api.nvim_buf_set_text(current_buf, row, col, row, col, { word })

      _G.current_suggestion = string.sub(_G.current_suggestion, #word + 1)

      M.clear_suggestion()
      if _G.current_suggestion and #_G.current_suggestion > 0 then
        M.set_suggestion_extmark(_G.current_suggestion)
      end

    else
      _G.current_suggestion = nil
      M.clear_suggestion()
    end
  end
end


-- ... (rest of the rktmb-deepseek-complete.lua file as before)
```

No changes are needed in `plugin/init.lua`.  The key mapping to `<M-Right>` already calls the updated `M.accept_suggestion_word()`.  The core logic for handling multi-line suggestions is within `M.set_suggestion_extmark()`, which is called after each word acceptance, ensuring correct placement of the remaining suggestion text.



Key improvements in `M.accept_suggestion_word()`:

* **Clearer word splitting:** Uses `%%%%s+` with the `plain` option for more robust word separation.
* **Handles multi-line gracefully:**  By clearing and redrawing the extmark after each word, the function implicitly handles multi-line suggestions.  The `M.set_suggestion_extmark()` function already correctly positions multi-line suggestions.
* **Clears suggestion when done:**  When all words are accepted, the suggestion is cleared.



This revised approach simplifies the code and makes it more efficient by leveraging the existing multi-line handling in `M.set_suggestion_extmark()`.  This eliminates the need for complex cursor position calculations within `M.accept_suggestion_word()`.

