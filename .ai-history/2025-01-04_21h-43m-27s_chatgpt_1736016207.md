# Propose inline suggestions from the random sentence generator

The final goal of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest.
But we are not going to implement all in one go, we are to make it step by step.

- Generate random sentences
- Make an inline suggestion from a random sentence when triggered.
- Query the DeepSeek API to get suggestions from the content of the buffer.
- Use the DeepSeek API response to suggest completions (dont use the random sentences anymore)

## Step 1: Generate a random sentence

in `./lua/rktmb-deepseek-complete.lua`, there is a function called `generate_sentence()`.
That function generates a multiline random sentence.
This is done.

## Step 2: Make an inline  suggestion from a random sentence when triggered.

When I am in a buffer and in INSERT mode and issue the key sequence `<M-PageDown>`,
I want the plugin to place de cursor at the end of the line and then suggest with a random sentence (which is multi line) picked from the list of sentences.

It is important to place the cursor at the end of the line before suggesting because suggestion is based on an existing text.

The suggestion text must appears in grey (#808080).

The suggestion text must push down the lines below it and not overlap with the text below.

If I continue to type after the suggestion is displayed, the suggestion must disappear.
As far as I type, I can trigger the suggestion again and if I continue to type, the suggestion must disappear, again and again.

Take the existing code and continue it in order to get what I want. 



# This is o1-preview answer (1k in, 4k out)

Great! Let's proceed to implement **Step 2**: making an inline suggestion from a random sentence when triggered.

We'll modify `plugin/init.lua` to achieve the desired functionality. Below is the updated code with explanations for each part.

---

### Updated `plugin/init.lua`

```lua
local rktmb_deepseek_complete = require("rktmb-deepseek-complete")
rktmb_deepseek_complete.log("Entered init.lua")

-- Define the highlight group for the suggestion text
vim.api.nvim_set_hl(0, "InlineSuggestion", { fg = "#808080", bg = "NONE" })

-- Global variables to keep track of extmarks
_G.current_extmarks = nil

-- Function to clear the current suggestion
local function clear_suggestion()
  if _G.current_extmarks then
    for _, extmark in pairs(_G.current_extmarks) do
      vim.api.nvim_buf_del_extmark(0, extmark.ns, extmark.id)
    end
    _G.current_extmarks = nil
  end
end

-- Function to show the suggestion when triggered
local function show_suggestion()
  clear_suggestion()
  -- Move the cursor to the end of the line
  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc><End>a", true, false, true), 'n', true)

  -- Generate a random sentence
  local suggestion = rktmb_deepseek_complete.generate_sentence()
  rktmb_deepseek_complete.log("Generated suggestion: " .. suggestion)

  -- Split the suggestion into lines
  local lines = vim.split(suggestion, "\n")
  -- Get the current buffer and cursor position
  local bufnr = vim.api.nvim_get_current_buf()
  local cursor_pos = vim.api.nvim_win_get_cursor(0)
  local cursor_line = cursor_pos[1] - 1 -- zero-indexed
  local cursor_col = cursor_pos[2]

  -- Create a namespace for our extmarks
  local ns_id = vim.api.nvim_create_namespace('rktmb-deepseek-complete')

  -- Set extmarks for each line of the suggestion
  _G.current_extmarks = {}

  for i, line in ipairs(lines) do
    local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, ns_id, cursor_line + i, 0, {
      virt_text = { { line, "InlineSuggestion" } },
      virt_text_pos = 'overlay',
    })
    table.insert(_G.current_extmarks, { ns = ns_id, id = extmark_id })
  end
end

-- Map <M-PageDown> to show_suggestion in insert mode
vim.keymap.set('i', '<M-PageDown>', show_suggestion, { noremap = true, silent = true })

-- Auto command to clear the suggestion when typing
vim.api.nvim_create_autocmd("TextChangedI", {
  pattern = "*",
  callback = function()
    clear_suggestion()
  end,
})

-- Auto command to clear the suggestion when leaving insert mode
vim.api.nvim_create_autocmd("InsertLeave", {
  pattern = "*",
  callback = function()
    clear_suggestion()
  end,
})
```

---

### Explanation

#### 1. Moving the Cursor to the End of the Line

We use `vim.api.nvim_feedkeys` to simulate the keypress `<Esc><End>a`, which moves the cursor to the end of the line and enters insert mode:

```lua
vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc><End>a", true, false, true), 'n', true)
```

#### 2. Generating a Random Sentence

We call the `generate_sentence()` function from our module to get a random multiline sentence:

```lua
local suggestion = rktmb_deepseek_complete.generate_sentence()
```

#### 3. Displaying the Suggestion Text

- **Splitting the Suggestion into Lines:**

  We split the multiline suggestion into individual lines:

  ```lua
  local lines = vim.split(suggestion, "\n")
  ```

- **Setting Up the Extmarks:**

  We use `vim.api.nvim_buf_set_extmark` with `virt_text` and `virt_text_pos = 'overlay'` to display the suggestion text inline, pushing down the lines below.

  ```lua
  for i, line in ipairs(lines) do
    local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, ns_id, cursor_line + i, 0, {
      virt_text = { { line, "InlineSuggestion" } },
      virt_text_pos = 'overlay',
    })
    table.insert(_G.current_extmarks, { ns = ns_id, id = extmark_id })
  end
  ```

  - **`virt_text`:** Specifies the text to display and applies the `InlineSuggestion` highlight group.
  - **`virt_text_pos = 'overlay'`:** Ensures the suggestion text appears as if it's part of the buffer, pushing down existing lines.

- **Collecting Extmark IDs:**

  We store the namespace and extmark IDs in `_G.current_extmarks` to be able to clear them later.

#### 4. Highlighting the Suggestion Text

We define the `InlineSuggestion` highlight group to display the suggestion in grey:

```lua
vim.api.nvim_set_hl(0, "InlineSuggestion", { fg = "#808080", bg = "NONE" })
```

#### 5. Clearing the Suggestion

- **`clear_suggestion()` Function:**

  This function deletes all extmarks associated with the current suggestion:

  ```lua
  local function clear_suggestion()
    if _G.current_extmarks then
      for _, extmark in pairs(_G.current_extmarks) do
        vim.api.nvim_buf_del_extmark(0, extmark.ns, extmark.id)
      end
      _G.current_extmarks = nil
    end
  end
  ```

- **Auto Commands:**

  - **When Typing (`TextChangedI`):**

    We set up an auto command to clear the suggestion whenever the user types:

    ```lua
    vim.api.nvim_create_autocmd("TextChangedI", {
      pattern = "*",
      callback = function()
        clear_suggestion()
      end,
    })
    ```

  - **When Leaving Insert Mode (`InsertLeave`):**

    We also clear the suggestion when the user leaves insert mode:

    ```lua
    vim.api.nvim_create_autocmd("InsertLeave", {
      pattern = "*",
      callback = function()
        clear_suggestion()
      end,
    })
    ```

#### 6. Key Mapping

We map `<M-PageDown>` in insert mode to trigger the `show_suggestion()` function:

```lua
vim.keymap.set('i', '<M-PageDown>', show_suggestion, { noremap = true, silent = true })
```

### Important Notes

- **Pushing Down Lines:**

  The use of `virt_text_pos = 'overlay'` along with setting the extmark on subsequent lines ensures that the suggestion text pushes down the lines below and doesn't overlap with existing text.

- **Clearing Suggestions:**

  The suggestion disappears when the user starts typing or leaves insert mode, as per your requirements.

- **Cursor Movement:**

  It's important to move the cursor to the end of the line before showing the suggestion to ensure that the suggestion is based on the existing text.

### Logging

We've added logging statements to help with debugging:

```lua
rktmb_deepseek_complete.log("Generated suggestion: " .. suggestion)
```

This logs the generated suggestion to `/tmp/rktmb-deepseek-complete.log`.

---

By incorporating these changes, your plugin will now:

- Display a multiline random sentence suggestion in grey when `<M-PageDown>` is pressed in insert mode.
- Place the cursor at the end of the line before showing the suggestion.
- Push down the lines below without overlapping.
- Automatically clear the suggestion when the user starts typing or leaves insert mode.
- Allow the user to trigger suggestions repeatedly as they type.

Let me know if you have any questions or need further assistance!

