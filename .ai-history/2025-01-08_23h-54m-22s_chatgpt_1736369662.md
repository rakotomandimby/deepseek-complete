## Step 7: accept the suggestion word by word

When a suggestion is displayed, I want the user to be able to accept it word by word with the `<M-Right>` key.
So, as far as there is a suggestion, if the user presses `<M-Right>`, 
the first word of the suggestion is accepted and transformed into text at the same position.

I implemented the logic for that in the `accept_suggestion_word()` function, but there are two problems:
- When the suggestion is on the same line as the cursor, it accepts the whole line.
- When the suggestion is directly on the line below the cursor, I get the error `'replacement string' item contains newlines`.
- When the suggestion is multiline, I get the error `'replacement string' item contains newlines`.

Tell me the modifications I need to make in order to accept one word at a time, then to accept the word on the line below if I have finished accepting the current line.




# This is o1-preview answer (3k in, 3k out)

Based on the issues you've described, let's analyze the `accept_suggestion_word()` function and address each problem one by one. We'll adjust the function to correctly accept suggestions word by word, handle multi-line suggestions, and avoid the errors you're encountering.

## Problem 1: Accepting the Whole Line Instead of One Word

**Issue:**
When the suggestion is on the same line as the cursor, accepting a word results in the entire line being inserted instead of just the first word.

**Cause:**
The `split_into_words` function isn't correctly splitting the suggestion into words due to the regular expression used. Additionally, when inserting the word, the function may be replacing more text than intended.

**Solution:**
- Correct the regular expression in `split_into_words` to properly split the text into words.
- Ensure that only the intended word is inserted at the cursor position without affecting other text.

## Problem 2 & 3: Error `'replacement string' item contains newlines`

**Issue:**
When accepting a word from a multi-line suggestion, you get the error `'replacement string' item contains newlines`.

**Cause:**
The `vim.api.nvim_buf_set_text` function expects the replacement text to be a list of strings without newline characters. If the word contains newlines, it raises this error.

**Solution:**
- Modify the function to handle multi-line suggestions by keeping track of the current position in the suggestion.
- Ensure that each insertion only includes text without newline characters.

---

Now, let's go through the modifications step by step.

### Step 1: Fix the `split_into_words` Function

The current implementation of `split_into_words` uses an incorrect pattern. Let's correct it.

**Replace:**

```lua
return vim.split(text, "%%%%s+", {plain=true})
```

**With:**

```lua
return vim.fn.split(text, "\\s\\+")
```

**Explanation:**

- The `vim.split` function doesn't support Lua patterns properly when splitting on whitespace.
- Using `vim.fn.split` with the Vim regex pattern `"\\s\\+"` correctly splits the text into words based on one or more whitespace characters.

### Step 2: Adjust `accept_suggestion_word()` to Handle Multi-line Suggestions

We need to keep track of the current position in the suggestion (line and column) and update it as we accept words.

**Modify the `accept_suggestion_word()` function as follows:**

#### Initialize Suggestion Position

At the top level of your module (outside any function), add:

```lua
_G.suggestion_line_index = 1
_G.suggestion_char_index = 1
```

This will track the line and character index within the suggestion.

#### Update the Function

**Replace the entire `accept_suggestion_word()` function with the following:**

```lua
function M.accept_suggestion_word()
    if _G.current_suggestion then
        local lines = vim.split(_G.current_suggestion, "\n")
        local line = lines[_G.suggestion_line_index] or ""
        local words = vim.fn.split(line:sub(_G.suggestion_char_index), "\\s\\+")

        if #words > 0 then
            local word = words[1]
            local current_buf = vim.api.nvim_get_current_buf()
            local position = vim.api.nvim_win_get_cursor(0)
            local row = position[1] - 1
            local col = position[2]

            -- Insert the accepted word into the buffer
            vim.api.nvim_buf_set_text(current_buf, row, col, row, col, {word})

            -- Move cursor forward
            vim.api.nvim_win_set_cursor(0, {row + 1, col + #word})

            -- Update indices
            _G.suggestion_char_index = _G.suggestion_char_index + #word
            local next_char = line:sub(_G.suggestion_char_index, _G.suggestion_char_index)
            if next_char == nil or next_char:match("%%s") then
                -- Skip whitespace
                _G.suggestion_char_index = _G.suggestion_char_index + 1
            end

            -- Check if we've reached the end of the line
            if _G.suggestion_char_index > #line then
                _G.suggestion_line_index = _G.suggestion_line_index + 1
                _G.suggestion_char_index = 1
                -- Move to next line in the buffer if suggestion spans multiple lines
                vim.api.nvim_win_set_cursor(0, {row + 2, 0})  -- Move cursor to the beginning of next line
            end

            -- Reconstruct remaining suggestion
            local remaining_lines = {}
            for i = _G.suggestion_line_index, #lines do
                local start_idx = (i == _G.suggestion_line_index) and _G.suggestion_char_index or 1
                table.insert(remaining_lines, lines[i]:sub(start_idx))
            end
            _G.current_suggestion = table.concat(remaining_lines, '\n')

            -- Update the displayed suggestion (clear and redraw)
            M.clear_suggestion()
            if _G.current_suggestion and #_G.current_suggestion > 0 then
                M.set_suggestion_extmark(_G.current_suggestion)
            end
        else
            -- No words left in the current line, move to the next line
            _G.suggestion_line_index = _G.suggestion_line_index + 1
            _G.suggestion_char_index = 1
            if _G.suggestion_line_index > #lines then
                -- All done with the suggestion
                _G.current_suggestion = nil
                M.clear_suggestion()
            else
                -- Recurse to accept word from next line
                M.accept_suggestion_word()
            end
        end
    end
end
```

**Explanation:**

- We split the suggestion into lines to handle multi-line suggestions.
- We use `_G.suggestion_line_index` and `_G.suggestion_char_index` to track our position in the suggestion.
- We extract the word starting from our current position.
- We insert the word into the buffer at the cursor position.
- We update our indices and cursor position accordingly.
- We rebuild the remaining suggestion and update the extmark.

### Step 3: Update `clear_suggestion()` Function

Ensure that `clear_suggestion()` resets the suggestion indices:

**Modify `clear_suggestion()` to include:**

```lua
_G.suggestion_line_index = 1
_G.suggestion_char_index = 1
```

**So the updated function becomes:**

```lua
function M.clear_suggestion()
    local current_buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_buf_clear_namespace(current_buf, _G.ns_id, 0, -1)

    -- Remove the inserted lines if any
    if _G.num_lines_inserted and _G.num_lines_inserted > 0 then
        local position = vim.api.nvim_win_get_cursor(0)
        local row = position[1] - 1 -- Adjust to 0-based indexing
        vim.api.nvim_buf_set_lines(current_buf, row + 1, row + 1 + _G.num_lines_inserted, false, {}) -- remove the inserted lines
        _G.num_lines_inserted = 0 -- Reset after removing lines
    end

    -- Reset suggestion indices
    _G.suggestion_line_index = 1
    _G.suggestion_char_index = 1
end
```

### Step 4: Adjust `set_suggestion_extmark()` Function

Ensure that the extmarks are correctly updated to reflect the remaining suggestion.

**Modify the function to adjust for the consumed text:**

Before setting the extmarks, adjust the suggestion text to account for the consumed words.

Add this at the beginning of `set_suggestion_extmark(suggestion)`:

```lua
-- Adjust the suggestion to account for consumed text
local lines = vim.split(suggestion, '\n', true)
for i = 1, _G.suggestion_line_index - 1 do
    table.remove(lines, 1)
end
if #lines > 0 then
    lines[1] = lines[1]:sub(_G.suggestion_char_index)
end
suggestion = table.concat(lines, '\n')
```

**So the function becomes:**

```lua
function M.set_suggestion_extmark(suggestion)
    -- Remove Markdown code block delimiters from the suggestion
    suggestion = M.remove_markdown_delimiters(suggestion)

    -- Adjust the suggestion to account for consumed text
    local lines = vim.split(suggestion, '\n', true)
    for i = 1, _G.suggestion_line_index - 1 do
        table.remove(lines, 1)
    end
    if #lines > 0 then
        lines[1] = lines[1]:sub(_G.suggestion_char_index)
    end
    suggestion = table.concat(lines, '\n')

    local current_buf = vim.api.nvim_get_current_buf()
    local position = vim.api.nvim_win_get_cursor(0)
    local row = position[1] - 1 -- Adjust to 0-based indexing
    local col = position[2]

    -- Split the suggestion into lines
    local lines = vim.split(suggestion, '\n', true)

    -- Now set the extmarks
    -- First line: virt_text on current line starting at cursor column
    vim.api.nvim_buf_set_extmark(
        current_buf,
        _G.ns_id,
        row,
        col,
        {
            virt_text = { { lines[1], "Comment" } },
            hl_mode = 'combine',
        }
    )

    -- Remaining lines: virt_text on the following lines
    for i = 2, #lines do
        local extmark_row = row + i - 1 -- Adjust row for each line
        vim.api.nvim_buf_set_extmark(
            current_buf,
            _G.ns_id,
            extmark_row,
            0,
            {
                virt_text = { { lines[i], "Comment" } },
                hl_mode = 'combine',
            }
        )
    end
    _G.num_lines_inserted = math.max(#lines - 1, 0)
end
```

### Step 5: Handle Insertion of Words Without Newlines

Ensure that the word being inserted does not contain newline characters, as `vim.api.nvim_buf_set_text` does not support strings with newlines.

In the `accept_suggestion_word()` function, confirm that `word` does not contain newlines.

**Modify the word extraction line:**

```lua
local word = words[1]
if word:find('\n') then
    word = word:gsub('\n', '')
end
```

But since we are extracting words based on spaces, it's unlikely to contain newlines. However, to be safe, ensure that when we insert text, it doesn't have newlines.

### Step 6: Testing

After making these changes, test the following scenarios:

- Accepting words from a single-line suggestion.
- Accepting words from a multi-line suggestion.
- Moving to the next line when the current line's words are all accepted.
- Ensuring no errors occur when accepting words at line boundaries.

---

## Summary

By modifying the `accept_suggestion_word()` function and related helpers, we:

- Correctly track the position within the suggestion.
- Handle multi-line suggestions.
- Avoid inserting newlines when accepting words.
- Provide a smooth experience when accepting suggestions word by word.

Let me know if you have any questions or need further assistance with these modifications.

