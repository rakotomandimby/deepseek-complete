# Propose inline suggestions from DeepSeek API

The final purpose of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest.
But we are not going to implement everything in one step, we are to make it step by step.

- Generate random sentences
- Make an inline suggestion from a random sentence when triggered.
- Have the possibility transform the inline suggestion into regular text (accepting the suggestion).
- Get the content of the current buffer know how to split it into 2 parts: 
    - the first part is the text from the begining of the buffer to the cursor position
    - the second part is the text from the cursor position to the end of the buffer
- Query the DeepSeek API to get suggestions from the content of the buffer.
- Use the DeepSeek API response to suggest completions (dont use the random sentences anymore)

## Step 1: Generate a random sentence

in `./lua/rktmb-deepseek-complete.lua`, there is a function called `generate_sentence()`.
That function generates a multiline random sentence.
This is done.

## Step 2: Make an inline  suggestion from a random sentence when triggered.

When I am in a buffer and in INSERT mode and issue the key sequence `<M-PageDown>`,
The plugin to place de cursor at the end of the line and then insert an inline suggestion 
taken from a random sentence (which is multi line) picked from the list of sentences.
The suggestion appears in grey (#808080).
The suggestion pushes down the lines below it and does not overlap with the text below.
If I continue to type after the suggestion is displayed, the suggestion disappears.
As far as I type, I can trigger the suggestion again and if I continue to type, the suggestion disappears, again and again.

That is the desired behavior.

## Step 3: Have the possibility transform the inline suggestion into regular text (accepting the suggestion).

Now the current code allows to transform the inline suggestion into regular text with the `<M-PageUp>` key sequence.

## Step 4: Get the text before and after the cursor then log it into the logs

Logging is achieved with the following code:

```
local rktmb_deepseek_complete = require("rktmb-deepseek-complete")
rktmb-deepseek-complete.log("The text to log")
```

When in INSERT mode and issue the `<M-PageDown>` key sequence, I want to add the feature to:
- put the cursor at the end of the line
- get the content from the beginning of the line to the cursor position and store it in a variable
- get the content from the cursor position to the end of the buffer and store it in a variable
- log the 2 variables into the logs

The features that already work must continue to work.

Tell me the modifications I need to make to the code in order to achieve what I want.




# This is gemini-exp-1206 answer (2k in, 0k out)

```lua
-- lua/rktmb-deepseek-complete.lua
local M = {}

function M.log(message)
  local log_file = io.open("/tmp/rktmb-deepseek-complete.log", "a")
  if log_file == nil then
    print("Error opening log file")
    return
  end
  log_file:write(message .. "\n")
  log_file:close()
end

function M.generate_sentence()
  M.log("Entered generate_sentence()")
  local sentences = { -- ... (unchanged)
  }
  return sentences[math.random(#sentences)]
end

return M
```

```lua
-- plugin/init.lua
local rktmb_deepseek_complete = require("rktmb-deepseek-complete")

_G.ns_id = vim.api.nvim_create_namespace('rktmb-deepseek-complete')

-- ... (other global variables)

_G.suggest_random_sentence = function()
  local current_row, current_col = unpack(vim.api.nvim_win_get_cursor(0))

  -- Get buffer content before and after cursor
  local current_buffer = vim.api.nvim_get_current_buf()
  local lines = vim.api.nvim_buf_get_lines(current_buffer, 0, -1, false)
  local text_before_cursor = table.concat(lines, "\n", 1, current_row - 1) .. string.sub(lines[current_row], 1, current_col)
  local text_after_cursor = string.sub(lines[current_row], current_col + 1) .. "\n" .. table.concat(lines, "\n", current_row + 1)


  rktmb_deepseek_complete.log("Text before cursor:\n" .. text_before_cursor)
  rktmb_deepseek_complete.log("Text after cursor:\n" .. text_after_cursor)


  -- Ensure the cursor is at the end of the current line
  local current_line = vim.api.nvim_get_current_line()
  vim.api.nvim_win_set_cursor(0, {current_row, #current_line})

  -- ... (rest of the function remains unchanged)
end

_G.accept_suggestion = function()
  -- ... (unchanged)
end

-- ... (autocommands and keymaps remain unchanged)
```

Key changes:

- **Getting cursor position:**  Now uses `local current_row, current_col = unpack(vim.api.nvim_win_get_cursor(0))` to get both row and column.
- **Getting buffer content:** Uses `vim.api.nvim_buf_get_lines` to get all lines, then concatenates them appropriately using `table.concat` and `string.sub` to extract the text before and after the cursor.
- **Logging:**  Logs the `text_before_cursor` and `text_after_cursor` using the provided `rktmb_deepseek_complete.log` function.


This revised code addresses Step 4 by capturing and logging the text before and after the cursor while preserving the existing functionality from Steps 1-3.  Remember to test thoroughly!  Let me know if you have any other questions.

