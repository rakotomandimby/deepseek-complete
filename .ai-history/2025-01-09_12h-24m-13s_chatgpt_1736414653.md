# Propose inline suggestions from DeepSeek API

The final purpose of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest completions.

I already have some pieces of code.
I need you to generate the missing parts.

## Step 1: Get the text from the beginning of the current buffer to the cursor

The cursor position is a tuple of (row, column), where row is the line number and column is the character position within the line.
The code to get the text from the beginning of the current buffer to the cursor is `./lua/rktmb-deepseek-complete.lua` function `M.get_text_before_cursor()`.

## Step 2: Get the text from the cursor to the end of the current buffer

In `./lua/rktmb-deepseek-complete.lua` I created the function `M.get_text_after_cursor()` 
that returns the text from the cursor to the end of the current buffer.

## Step 3: Query the DeepSeek API

When the user presses `<M-ESC>`, the function `suggest()` is called. That is the behavior I want.
Also, now, if in INSERT mode and the user presses the space key, `suggest()` is called.

That is the behavior I want.

## Step 4: Insert the suggestion as extmark

Now the suggestion returned by the DeepSeek API is inserted as an extmark.
The extmark starts after the cursor position, NOT at the end of the line.
The suggestion first line is displayed on the same line as the cursor and the remaining lines are displayed below the cursor, 
pushing down the text below the cursor.

That is the expected behavior.

## Step 5: Avoid trigerring the suggestion too often

When the user types fast, the suggestion may only be triggered if the last HTTP response has been received for more than 1 second.
That is the behavior I want.

## Step 6: Clear the suggestion when the user types.

As the user types `<M-ESC>` key, a suggestion is triggered and the suggestion is displayed as an extmark.
If the user continues typing, the suggestion is cleared.
If the types `<M-ESC>` key again, the suggestion is triggered and the new suggestion is displayed when it arrives.
This is repeatable any number of times.

This is the behavior I want.

## Step 7: accept the suggestion word by word

When a suggestion is displayed, I want the user to be able to accept it word by word with the `<M-Right>` key.
So, as far as there is a suggestion, if the user presses `<M-Right>`, 
the first word of the suggestion is accepted and transformed into text at the same position.

Note: Gihub Copilot and Supermaven Neovim plugins do that.

The suggestion might be on the same line as the cursor or on a different line: we have to handle that case.

Tell me the modifications I need to make in order to achieve accepting words of a suggestion and continue to the next line if the suggestion is multiline.



# This is o1-preview answer (3k in, 3k out)

To achieve the desired behavior of accepting words from a suggestion that may span multiple lines, we need to modify the `accept_suggestion_word()` function and related helper functions to handle newlines properly. The goal is to:

- Accept words one by one, even when the suggestion is multiline.
- Move the cursor to a new line if the next word in the suggestion starts on a new line.
- Update the displayed suggestion accordingly.

Here's how you can achieve this:

---

## **Step 1: Improve Word Splitting to Handle Newlines**

Currently, the `split_into_words()` function does not account for newlines. We need to adjust it so that it recognizes when words are on a new line.

**Modification:**

Update `split_into_words(text)` to handle newlines properly by splitting the text into words while preserving newline information.

**New Implementation:**

```lua
local function split_into_words(text)
  -- Split the text into words, including newlines as separate tokens
  local words = {}
  for token in text:gmatch("[^\n%%s]+") do
    table.insert(words, token)
  end
  return words
end
```

Alternatively, to include newlines as tokens:

```lua
local function split_into_words(text)
  local words = {}
  for line in text:gmatch("([^\n]*)\n?") do
    for word in line:gmatch("%%S+") do
      table.insert(words, word)
    end
    -- If there was a newline, add a special token
    if line ~= "" then
      table.insert(words, "\n")
    end
  end
  return words
end
```

However, this approach can be complex. A better way is to iterate over the text character by character and build words, but for simplicity, let's adjust our logic to handle newlines within the existing approach.

## **Step 2: Modify `accept_suggestion_word()` to Handle Newlines**

We need to adjust the function to:

1. Check if the next word starts with a newline character.
2. If there's a newline before the next word, move the cursor to the beginning of the next line before inserting the word.
3. Update the suggestion by removing the accepted word and any preceding newline.

**Modification:**

Update `accept_suggestion_word()` to handle newlines.

**New Implementation:**

```lua
function M.accept_suggestion_word()
    if _G.current_suggestion then
        -- Find the position of the next space or newline
        local next_space = _G.current_suggestion:find("%%s")
        local next_newline = _G.current_suggestion:find("\n")
        local split_pos = nil

        if next_space and next_newline then
            split_pos = math.min(next_space, next_newline)
        elseif next_space then
            split_pos = next_space
        elseif next_newline then
            split_pos = next_newline
        end

        local word = ""
        if split_pos then
            word = _G.current_suggestion:sub(1, split_pos - 1)
        else
            word = _G.current_suggestion
        end

        -- Check for leading newline characters
        local leading_newlines = _G.current_suggestion:match("^\n+")
        local num_newlines = leading_newlines and #leading_newlines or 0

        local current_buf = vim.api.nvim_get_current_buf()
        local position = vim.api.nvim_win_get_cursor(0)
        local row = position[1] - 1
        local col = position[2]

        -- Move cursor down if there are leading newlines
        if num_newlines > 0 then
            row = row + num_newlines
            col = 0
            vim.api.nvim_win_set_cursor(0, { row + 1, col })
        end

        -- Insert the accepted word into the buffer
        vim.api.nvim_buf_set_text(current_buf, row, col, row, col, { word })

        -- Update cursor position after insertion
        col = col + #word
        vim.api.nvim_win_set_cursor(0, { row + 1, col })

        -- Remove the accepted word and any leading whitespace/newlines from the suggestion
        _G.current_suggestion = _G.current_suggestion:sub(#leading_newlines + #word + 1):gsub("^%%s*", "")

        -- Update the displayed suggestion (clear and redraw)
        M.clear_suggestion()
        if _G.current_suggestion and #_G.current_suggestion > 0 then
            M.set_suggestion_extmark(_G.current_suggestion)
        else
            _G.current_suggestion = nil -- Clear suggestion if no text left
        end
    end
end
```

**Explanation:**

- **Handling Leading Newlines:**
  - We check for any leading newline characters in the suggestion.
  - If there are newlines, we increment the row position and reset the column to 0.
  - We move the cursor to the new position before inserting the word.

- **Inserting the Word:**
  - We insert the word at the current cursor position.

- **Updating Cursor Position:**
  - After insertion, we update the column position.
  - We move the cursor to the new position to reflect the inserted text.

- **Updating the Suggestion:**
  - We remove the accepted word and any leading whitespace or newlines from `_G.current_suggestion`.
  - We clear and redraw the suggestion if there's remaining text.

## **Step 3: Update `split_into_words()` Function**

Since we're handling the splitting within `accept_suggestion_word()`, we may no longer need `split_into_words()`. However, if you prefer to keep it, ensure it handles newlines appropriately.

---

**Alternative Approach:**

If you want to keep `split_into_words()` and handle newlines as tokens, you can modify it as follows:

```lua
local function split_into_words(text)
    local words = {}
    local pos = 1
    local length = #text

    while pos <= length do
        local c = text:sub(pos, pos)
        if c == "\n" then
            table.insert(words, "\n")
            pos = pos + 1
        elseif c:match("%%s") then
            -- Skip whitespace
            pos = pos + 1
        else
            local start_pos = pos
            while pos <= length and not text:sub(pos, pos):match("%%s") do
                pos = pos + 1
            end
            local word = text:sub(start_pos, pos - 1)
            table.insert(words, word)
        end
    end

    return words
end
```

Then, update `accept_suggestion_word()` accordingly:

```lua
function M.accept_suggestion_word()
    if _G.current_suggestion then
        local words = split_into_words(_G.current_suggestion)
        if #words > 0 then
            local word = words[1]
            local current_buf = vim.api.nvim_get_current_buf()
            local position = vim.api.nvim_win_get_cursor(0)
            local row = position[1] - 1
            local col = position[2]

            if word == "\n" then
                -- Move to the next line
                row = row + 1
                col = 0
                vim.api.nvim_win_set_cursor(0, { row + 1, col })
            else
                -- Insert the accepted word into the buffer
                vim.api.nvim_buf_set_text(current_buf, row, col, row, col, { word })
                -- Update cursor position
                col = col + #word
                vim.api.nvim_win_set_cursor(0, { row + 1, col })
            end

            -- Remove the accepted word from the suggestion
            local word_length = #word
            if word == "\n" then
                word_length = 1  -- Length of the newline character
            end
            _G.current_suggestion = _G.current_suggestion:sub(word_length + 1):gsub("^%%s*", "")

            -- Update the displayed suggestion (clear and redraw)
            M.clear_suggestion()
            if _G.current_suggestion and #_G.current_suggestion > 0 then
                M.set_suggestion_extmark(_G.current_suggestion)
            else
                _G.current_suggestion = nil -- Clear suggestion if no words left
            end
        else
            _G.current_suggestion = nil -- Clear suggestion if no words left
            M.clear_suggestion()
        end
    end
end
```

## **Step 4: Update `set_suggestion_extmark()` Function**

Ensure that `set_suggestion_extmark()` correctly displays the updated suggestion after words are accepted, especially when the suggestion spans multiple lines.

Verify that the function handles the inserted lines properly and adjusts the extmarks accordingly.

---

## **Testing the Modifications**

After implementing the changes, test the functionality:

1. Trigger a suggestion that spans multiple lines.
2. Press `<M-Right>` to accept words one by one.
3. Observe that when a newline is encountered:
   - The cursor moves to the next line.
   - The next word is inserted at the beginning of the new line.
4. Verify that the remaining suggestion is updated and displayed correctly.

## **Additional Considerations**

- **Whitespace Handling:**
  - Ensure that any leading whitespace after accepting a word is handled appropriately.
  - You might want to adjust the regex patterns in `split_into_words()` or when updating `_G.current_suggestion`.

- **Edge Cases:**
  - Test cases where the suggestion starts with newlines or multiple spaces.
  - Ensure that accepting words works seamlessly in these scenarios.

- **Cursor Position:**
  - After each word is accepted, ensure the cursor is accurately positioned for the next insertion.
  - This is crucial for providing a smooth user experience.

---

## **Summary**

By modifying the `accept_suggestion_word()` function to handle newlines and adjusting the word splitting logic, you can achieve the desired behavior of accepting words from a multiline suggestion and correctly moving to new lines when necessary. The key is to recognize newline characters as part of the suggestion and adjust the cursor position and insertion point accordingly.

Feel free to adjust the code snippets to better fit into your existing codebase, and test thoroughly to ensure all scenarios are handled as expected.

