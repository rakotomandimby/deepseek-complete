# Propose inline suggestions from DeepSeek API

The final purpose of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest completions.

I already have some pieces of code.
I need you to generate the missing parts.

## Step 1: Get the text from the beginning of the current buffer to the cursor

The cursor position is a tuple of (row, column), where row is the line number and column is the character position within the line.
The code to get the text from the beginning of the current buffer to the cursor is `./lua/rktmb-deepseek-complete.lua` function `M.get_text_before_cursor()`.

## Step 2: Get the text from the cursor to the end of the current buffer

In `./lua/rktmb-deepseek-complete.lua` I created the function `M.get_text_after_cursor()` 
that returns the text from the cursor to the end of the current buffer.

## Step 3: Query the DeepSeek API

When the user presses `<M-ESC>`, the function `suggest()` is called. That is the behavior I want.
Also, now, if in INSERT mode and the user presses the space key, `suggest()` is called.

That is the behavior I want.

## Step 4: Insert the suggestion as extmark

Now the suggestion returned by the DeepSeek API is inserted as an extmark.
The extmark starts after the cursor position, NOT at the end of the line.

Problem: The DeepSeek API response is a multiline string and it is displayed with `^@` at the end of each line.

Tell me what modifications I need to make to the code in order to really split the suggestion into lines.




# This is gpt-4o-mini answer (3k in, 1k out)

To modify your Neovim plugin to properly handle the multiline suggestions returned by the DeepSeek API, you will need to make a few changes to the `process_deepseek_response` function in `plugin/init.lua`. Specifically, you will need to split the suggestion into lines and ensure that the extmark is set correctly.

Here’s how you can do it:

### Step 1: Modify the `process_deepseek_response` function

You will need to split the suggestion into lines and handle the insertion of the extmark accordingly. Here’s the modified `process_deepseek_response` function:

```lua
local function process_deepseek_response(response)
  vim.schedule(function()  -- Use vim.schedule to run this in the main thread
    local response_body = vim.fn.json_decode(response.body)
    if response_body.choices and #response_body.choices > 0 then
      local choice = response_body.choices[1]
      local suggestion = choice.message.content
      
      -- Split the suggestion into lines
      local suggestion_lines = vim.split(suggestion, "\n", true)
      
      rktmb_deepseek_complete.log("\n\nSuggestion from DeepSeek API:")
      rktmb_deepseek_complete.log(suggestion)
      
      -- Insert each line as an extmark
      for _, line in ipairs(suggestion_lines) do
        rktmb_deepseek_complete.set_suggestion_extmark(line)
      end
      
      _G.current_suggestion = suggestion -- Store the current suggestion
    end
  end)
end
```

### Step 2: Ensure the extmark is set correctly

The `set_suggestion_extmark` function already handles the insertion of the extmark after the cursor position. However, since you are now inserting multiple lines, you may want to adjust the logic to ensure that each line is placed correctly. 

The current implementation of `set_suggestion_extmark` should work as is, but you may want to ensure that it handles the `end_row` and `end_col` correctly for each line. 

### Full Updated `plugin/init.lua`

Here’s the full content of `plugin/init.lua` with the modifications:

```lua
local rktmb_deepseek_complete = require("rktmb-deepseek-complete")
local curl = require('plenary.curl')

_G.ns_id = vim.api.nvim_create_namespace('rktmb-deepseek-complete')

_G.current_extmark_id = nil
_G.current_suggestion = nil

-- Default keymappings
local default_opts = {
  deepseek_api_key = os.getenv("DEEPSEEK_API_KEY"),
  suggest_lines_keymap = "<M-ESC>",
  accept_all_keymap = "<M-PageDown>",
  accept_line_keymap = "<M-Down>",
}

-- Read user configuration
local user_opts = vim.tbl_deep_extend("force", default_opts, vim.g.rktmb_deepseek_complete_opts or {})

local function process_deepseek_response(response)
  vim.schedule(function()  -- Use vim.schedule to run this in the main thread
    local response_body = vim.fn.json_decode(response.body)
    if response_body.choices and #response_body.choices > 0 then
      local choice = response_body.choices[1]
      local suggestion = choice.message.content
      
      -- Split the suggestion into lines
      local suggestion_lines = vim.split(suggestion, "\n", true)
      
      rktmb_deepseek_complete.log("\n\nSuggestion from DeepSeek API:")
      rktmb_deepseek_complete.log(suggestion)
      
      -- Insert each line as an extmark
      for _, line in ipairs(suggestion_lines) do
        rktmb_deepseek_complete.set_suggestion_extmark(line)
      end
      
      _G.current_suggestion = suggestion -- Store the current suggestion
    end
  end)
end

_G.suggest = function()
  local deepseek_request_body = {
    model = "deepseek-chat",
    echo = false,
    frequency_penalty = 0,
    max_tokens = 4096,
    presence_penalty = 0,
    stop = nil,
    stream = false,
    stream_options = nil,
    temperature = 1,
    top_p = 1,
    messages = rktmb_deepseek_complete.build_messages_table(
      rktmb_deepseek_complete.get_text_before_cursor(),
      rktmb_deepseek_complete.get_text_after_cursor(),
      rktmb_deepseek_complete.get_text_before_cursor_line()
    )
  }

  -- Asynchronously make the POST request
  curl.post('https://api.deepseek.com/chat/completions', {
    body = vim.fn.json_encode(deepseek_request_body),
    headers = {
      ["Content-Type"] = "application/json",
      ["Accept"] = "application/json",
      ["Authorization"] = "Bearer " .. user_opts.deepseek_api_key
    },
    callback = function(response)
      rktmb_deepseek_complete.log("Response from DeepSeek API:")
      rktmb_deepseek_complete.log(response.body)
      process_deepseek_response(response)
    end
  })
end

vim.api.nvim_create_autocmd("InsertLeave", {
  pattern = "*",
  callback = function()
    vim.api.nvim_buf_clear_namespace(0, ns_id, 0, -1)
  end
})

-- Key mappings
vim.api.nvim_set_keymap("i", user_opts.suggest_lines_keymap, "<Cmd>lua suggest()<CR>", { noremap = true, silent = true })

-- Space key
vim.api.nvim_set_keymap("i", " ", "<Cmd>lua suggest()<CR> ", { noremap = true, silent = true })
```

### Summary

1. **Split the suggestion**: The suggestion is split into lines using `vim.split`.
2. **Insert each line**: Each line is inserted as an extmark using the existing `set_suggestion_extmark` function.

With these modifications, your plugin should now correctly handle multiline suggestions from the DeepSeek API and display them as extmarks in Neovim.

