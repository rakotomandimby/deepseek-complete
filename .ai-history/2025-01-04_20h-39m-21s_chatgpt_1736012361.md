# Propose inline suggestions from the random sentence generator

The final goal of this project is to be an inline suggestion plugin that uses the DeepSeek API to suggest.
But we are not going to implement all in one go.
We are to make it step by step.

- Generate a random sentences
- Make an inline suggestion from a random sentence when triggered.
- Query the DeepSeek API to get suggestions from the content of the buffer.
- Use the DeepSeek API response to suggest completions (dont use the random sentences anymore)

## Step 1: Generate a random sentence

in `./lua/rktmb-deepseek-complete.lua`, there is a function called `generate_sentence()`.
That function generates a multiline random sentence.

## Step 2: Make an inline  suggestion from a random sentence when triggered.

When I am in a buffer and in INSERT mode and issue the key sequence `<M-PageDown>`,
the plugin suggests with a random sentence picked from the list of sentences. 
The suggestion text appears in grey.

If the sentence contains a newline, the suggestion is splat into multiple lines.

That is good.


But sometimes, If I put the cursor on any word or line then trigger the completion, I get the following error:

```
Error executing vim.schedule lua callback: ....local/share/nvim/lazy/deepseek-complete/plugin/init.lua:41: Invalid 'col': out of range
stack traceback:
        [C]: in function 'nvim_buf_set_extmark'
        ....local/share/nvim/lazy/deepseek-complete/plugin/init.lua:41: in function ''
        vim/_editor.lua: in function ''
        vim/_editor.lua: in function <vim/_editor.lua:0>
```

Analyze the code and find all causes possible to get the error above and propose me a fix.



# This is gpt-4o-mini answer (1k in, 1k out)

The error message you're encountering indicates that the column index being passed to the `nvim_buf_set_extmark` function is out of range. This can happen for a few reasons, particularly when the cursor is positioned at the end of a line or if the line is shorter than the column index being used.

### Possible Causes of the Error

1. **Cursor at the End of the Line**: If the cursor is at the end of a line, the column index will be equal to the length of the line, which is out of range since valid column indices are 0-based and should be less than the length of the line.

2. **Empty Lines**: If the current line is empty, the column index will also be out of range.

3. **Newline Characters**: If the suggestion contains newline characters, the way the extmarks are set might not account for the new lines properly, leading to incorrect column indices.

### Proposed Fix

To fix the issue, we need to ensure that the column index is always valid before calling `nvim_buf_set_extmark`. We can do this by adjusting the column index to be within the valid range. Here’s how you can modify the relevant part of your `plugin/init.lua` file:

```lua
-- Adjust the column index to be within the line length
local adjusted_col = math.min(current_col, #current_line)

-- Ensure adjusted_col is not negative
adjusted_col = math.max(adjusted_col, 0)

for i, line in ipairs(lines) do
    -- Calculate the line index for the extmark
    local line_index = vim.api.nvim_win_get_cursor(0)[1] - 1 + i - 1

    -- Ensure the line index is within the buffer's line count
    if line_index < vim.api.nvim_buf_line_count(0) then
        local extmark_id = vim.api.nvim_buf_set_extmark(0, ns_id, line_index, adjusted_col, {
            virt_text = {{line, "InlineSuggestion"}},
            virt_text_pos = "overlay",
            hl_mode = "combine"
        })
        table.insert(_G.current_extmarks, {ns = ns_id, id = extmark_id})
    end
end
```

### Explanation of the Fix

1. **Adjusting the Column Index**: We ensure that `adjusted_col` is not negative by using `math.max(adjusted_col, 0)`. This prevents any out-of-range errors when the cursor is at the start of a line.

2. **Validating Line Index**: Before setting the extmark, we check if the `line_index` is within the valid range of lines in the buffer using `vim.api.nvim_buf_line_count(0)`. This prevents trying to set an extmark on a non-existent line.

### Updated `plugin/init.lua`

Here’s the updated section of your `plugin/init.lua` file with the proposed changes:

```lua
-- ... (previous code)

local function clear_suggestion()
    if _G.current_extmarks then
        for _, extmark in ipairs(_G.current_extmarks) do
            vim.api.nvim_buf_del_extmark(0, extmark.ns, extmark.id)
        end
        _G.current_extmarks = nil
    end
end

vim.api.nvim_create_autocmd("InsertEnter", {
    pattern = "*",
    callback = function()
        _G.completion_handler = function()
            local current_line = vim.api.nvim_get_current_line()
            local current_col = vim.api.nvim_win_get_cursor(0)[2]
            local current_word = vim.fn.expand("<cword>")

            local suggestion = rktmb_deepseek_complete.generate_sentence()
            local lines = vim.split(suggestion, "\n")
            -- log the lines
            rktmb_deepseek_complete.log("Lines:")
            for _, line in ipairs(lines) do
                rktmb_deepseek_complete.log(line)
            end
            rktmb_deepseek_complete.log("End of lines")

            clear_suggestion()

            local ns_id = vim.api.nvim_create_namespace("rktmb-deepseek-complete-ns")
            _G.current_extmarks = {}

            -- Adjust the column index to be within the line length
            local adjusted_col = math.min(current_col, #current_line)
            adjusted_col = math.max(adjusted_col, 0)

            for i, line in ipairs(lines) do
                local line_index = vim.api.nvim_win_get_cursor(0)[1] - 1 + i - 1

                -- Ensure the line index is within the buffer's line count
                if line_index < vim.api.nvim_buf_line_count(0) then
                    local extmark_id = vim.api.nvim_buf_set_extmark(0, ns_id, line_index, adjusted_col, {
                        virt_text = {{line, "InlineSuggestion"}},
                        virt_text_pos = "overlay",
                        hl_mode = "combine"
                    })
                    table.insert(_G.current_extmarks, {ns = ns_id, id = extmark_id})
                end
            end
        end

        -- ... (rest of the code)
    end
})

-- ... (rest of the code)
```

### Conclusion

With these changes, your plugin should handle the edge cases that lead to the "Invalid 'col': out of range" error, allowing for a smoother user experience when generating inline suggestions.

