## Step 7: accept the suggestion word by word

When a suggestion is displayed, I want the user to be able to accept one word with the `<M-Right>` key.

As far as there is a suggestion, if the user presses `<M-Right>`, 
the first word of the suggestion is accepted and transformed into text at the same position.

Note: Gihub Copilot and Supermaven Neovim plugins do that.

The suggestion might be on the same line as the cursor or on a different line: we have to handle that case.

With the current implementation, if the suggestion is on the same line as the cursor, he get the following error:

```
E5108: Error executing lua ...m/lazy/deepseek-complete/lua/rktmb-deepseek-complete.lua:92: attempt to get length of local 'leading_newlines' (a nil value)
```

This is because `M.accept_suggestion_word()` looks for a leading newline character in the suggestion but there is none because the suggestion is on the same line as the cursor.

Tell me the changes I need to make in order to achieve accepting one word of a suggestion when issuing the `<M-Right>` key until the end of the line. Then continue to the next line, and so on.



# This is gemini-1.5-pro-latest answer (4k in, 1k out)

The error you're encountering is because `string.match` returns `nil` if there's no match, and you're trying to get the length of `nil` on this line:

```lua
local num_newlines = leading_newlines and #leading_newlines or 0
```

While this line handles the `nil` case, the error occurs *before* this line, specifically when you try to get the length of  `leading_newlines`  *directly* within the conditional expression.

Here's the corrected `lua/rktmb-deepseek-complete.lua` file:

```lua
-- lua/rktmb-deepseek-complete.lua
-- ... (rest of the code)

function M.accept_suggestion_word()
    if _G.current_suggestion then
        -- Find the position of the next space or newline
        local next_space = _G.current_suggestion:find("%%%%%%%%s") or _G.current_suggestion:find(" ") -- Also split on normal spaces
        local next_newline = _G.current_suggestion:find("\n")
        local split_pos = nil

        if next_space and next_newline then
            split_pos = math.min(next_space, next_newline)
        elseif next_space then
            split_pos = next_space
        elseif next_newline then
            split_pos = next_newline
        end

        local word = ""
        if split_pos then
            word = _G.current_suggestion:sub(1, split_pos - 1)
        else
            word = _G.current_suggestion
        end

        -- Handle leading newlines correctly
        local leading_newlines = _G.current_suggestion:match("^\n+")
        local num_newlines = (leading_newlines and #leading_newlines) or 0 -- Fix: Get length only if not nil


        local current_buf = vim.api.nvim_get_current_buf()
        local position = vim.api.nvim_win_get_cursor(0)
        local row = position[1] - 1
        local col = position[2]

        -- Move cursor down if there are leading newlines
        if num_newlines > 0 then
            row = row + num_newlines
            col = 0 -- Start at the beginning of the line
            vim.api.nvim_win_set_cursor(0, { row + 1, col })
        end

        -- Insert the accepted word into the buffer
        vim.api.nvim_buf_set_text(current_buf, row, col, row, col, { word })

        -- Update cursor position after insertion
        col = col + #word
        vim.api.nvim_win_set_cursor(0, { row + 1, col })

        -- Remove the accepted word and any leading whitespace/newlines from the suggestion
        _G.current_suggestion = _G.current_suggestion:sub(#leading_newlines + #word + 1):gsub("^%%%%%%%%s*", ""):gsub("^%%%%s*", "") -- Also remove normal spaces

        -- Update the displayed suggestion (clear and redraw)
        M.clear_suggestion()
        if _G.current_suggestion and #_G.current_suggestion > 0 then
            M.set_suggestion_extmark(_G.current_suggestion)
        else
            _G.current_suggestion = nil -- Clear suggestion if no text left
        end
    end
end

-- ... (rest of the code)
```

Key changes:

1. **Handle `nil` for `leading_newlines`:**  The main fix is ensuring we don't try to get the length of `leading_newlines` if it's `nil`.  The corrected line uses the `or` operator correctly now.

2. **Handle regular spaces:** The original code only split on `%%%%%%%%s` placeholders.  I've added splitting on regular spaces as well, using `_G.current_suggestion:find(" ")`.  The removal of leading spaces after accepting a word is also included using `:gsub("^%%%%s*", "")`.

3. **Cursor Placement with Newlines:** The cursor placement logic when encountering newlines is improved to set the column to 0, ensuring the word is inserted at the beginning of the new line.



No changes are needed in `plugin/init.lua`.  This corrected `M.accept_suggestion_word` function should resolve the error and implement the word-by-word acceptance behavior correctly, handling both single-line and multi-line suggestions.
